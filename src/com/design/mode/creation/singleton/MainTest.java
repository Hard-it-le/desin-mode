package com.design.mode.creation.singleton;

/**
 * @author 余嘉乐
 * @date 2022/09/19
 *
 * 单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。
 *
 * 单例模式的优点
 * *
 * 单例模式的缺点
 * * 单例对 OOP 特性的支持不友好 如果选择将某个类设计成到单例类，也意味着放弃了继承和多态这两个有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。
 * * 单例会隐藏类之间的依赖关系 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用。如果代码比较复杂，在阅读代码时候，需要查看每个函数的具体实现才会知道详细内容
 * * 单例对代码的扩展性不友好 单例类在某些情况下会影响代码的扩展性、灵活性。在数据库连接池、线程池这种资源池、共享池，一般不建议设置成单例类
 * * 单例对代码的可测试性不友好 单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。
 * * 单例不支持有参数的构造函数 单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。
 *  * 解决方案
 *      * 创建完实例之后，在调用 init函数传递参数
 *      * 将参数放到 getIntance方法中
 *      * 将参数放到另外一个全局变量中
 *
 * 单例模式在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。
 * 这新老进程的对象不是同一个对象，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。
 *
 * 单例模式的唯一性
 *  * 进程唯一 进程内唯一，进程间不唯一
 *  * 线程唯一 线程内唯一，线程间不唯一
 *  线程内、线程间都唯一
 *  * 集群唯一clear 进程内唯一、进程间唯一
 *
 **/
public class MainTest {
}