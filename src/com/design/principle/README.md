# 设计模式的七大原则

优良的系统设计具备特点：

- 可扩展性(Extensibility)
- 灵活性(Flexibility)
- 组件化可插拔式(Plurality)


面向对象编程常用的设计原则并不是孤立存在的， 它们相互依赖、 相互补充。

## 开闭原则

开闭原则 （Open-Closed Principle, OCP） 是指一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭。

开闭原则还可以通过一个更加具体的 “ 对可变性封装原则 ” 来描述， 对可变性封装原则(EVP)要求找到系统的可变因素并将其封装起来。

所谓的开闭， 也正是对扩展和修改两个行为的一个原则。 强调的是用抽象构建框架， 用实现扩展细节。 可以提高软件系统的可复用性及可维护性。

开闭原则，是面向对象设计中最基础的设计原则。 它指导我们如何建立稳定灵活的系统，如果一个软件设计符合开闭原则， 那么可以非常方便地对系统进行扩展， 而且在扩展时无须修改现有代码， 使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。例如： 我们版本更新， 我尽可能不修改源代码， 但是可以增加新功能。

为了满足开闭原则， 需要对系统进行抽象化设计， 抽象化是开闭原则的关键。


##     依赖倒置原则

依赖倒置原则 （ Dependence Inversion Principle,DIP） 是指设计代码结构时， 高层模块不应该依赖底层模块， 二者都应该依赖其抽象。

抽象不应该依赖细节； 细节应该依赖抽象。 通过依赖倒置， 可以减少类与类之间的耦合性， 提高系统的稳定性， 提高代码的可读性和可维护性，并能够降低修改程序所 造成的风险。

依赖倒置原则的注意事项：

-  依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类， 即使用接 口和抽象类进行变量类型声明、 参数类型声明、 方法返回类型声明， 以及数据 类型的转换等， 而不要用具体类来做 这些事情。
- 为了确保该原则的应用， 一个具体类应当只 实现接口或抽象类中声明过的方法， 而不要给出多余的方法， 否则将无法调用到在子类中增 加的新方法。
- 在引入抽象层后，系统将具有很好的灵活性， 在程序中尽量使用抽象层进行编程， 而将具体类写在配置文件中， 这样一来， 如果系统行为发生变化， 只需要对抽象层进行扩展， 并修改配置文件， 而无须修改原有系统的源代码， 在 不修改的情况下来扩展系统的功能， 满足开闭原则的要求。
-  在实现依赖倒转原则时， 我们需要针对抽象层编程， 而将具体类的对象通过依赖注入(DependencyInjection, DI)的 方式注入到其他对象中， 依赖注入是指当一个对象要与其他对象发 生依赖关系时， 通过抽象来注入所依赖的对象。 常用的注入方式有三种， 分别是： 构造注 入， 设值注入（ Setter 注入） 和接口注入。 构造注入是指通过构造函数来传 入具体类的对象， 设值注入是指通过 Setter 方法来传入具体类的对象， 而接口注入是指通过在接口中声明的业务 方 法来传入具体类的对象。 这些方法在定义时使用的是抽象类型， 在运行时再传入具体类型 的对象， 由子类对象来覆 盖父类对象。

总结

- 针对接口编程
- 在接口或抽象类中定义方法、声明变量
- 类只实现接口或抽象类中的方法，不要定义多余的方法
- 给抽象对象或接口注入依赖对象时，采用依赖注入方式

## 单一职责原则

单一职责（Simple  Responsibility Principle， SRP）是一个对象应该只包含单一的职责， 并且该职责被完整地封装在一个类中。

一个类（或者大到模块， 小到方法） 承担的职责越多， 它被复用的可能性越小， 而且如果一个类承担的职责过多， 就相当于将这些职责耦合在一起， 当其中一个职责变化时， 可能会影响其他职责的运作。

类的职责主要包括两个方面： 数据职责和行为职责， 数据职责通过其属性来体现， 而行为职责通过其方法来体现。

单一职责原则是实现高内聚、低耦合的指导方针， 在很多代码重构方法中都能找到它的存在， 它是最简单但又最难运用的原则， 需要设计人员发现类的不同职责并将其分离， 而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

### 接口隔离原则

接口隔离原则 （ Interface Segregation Principle, ISP） 是指用多个专门的接口， 而不使用单一的 总接口， 客户端不应该依赖它不需要的接口。

接口隔离原则的注意事项：

-  一个类对一类的依赖应该建立在最小的接口之上。
- 建立单一接口， 不要建立庞大臃肿的接口。
- 尽量细化接口， 接口中的方法尽量少（不是越少越好， 一定要适度） 。



接口隔离原则符合我们常说的高内聚低耦合的设计思想， 从而使得类具有很好的可读性、 可扩展性和可维护性。 我们在设计接口的时候， 要多花时间去思考， 要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以， 对于抽象， 对业务模型的理解是非常重要的。



接口仅仅提供客户端需要的行为， 客户端不需要的行为则隐藏起来， 应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。

在面向对象编程语言中， 实现一个接口就需要实现该接口中定义的所有方法， 因此大的总接口使用起来不一定很方便， 为了使接口的职责单一， 需要将大接口中的方法根据其职责不同分别放在不同的小接口中， 以确保每个接口使用起来都较为方便， 并都承担某一单一角色。 接口应该尽量细化， 同时接口中的方法应该尽量少， 每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可， 这种机制也称为 “ 定制服务 ” ， 即 为不同的客户端提供宽窄不同的接口。

总结：

需要用到哪些方法， 接口中就只提供哪些方法， 用不到的方法， 接口中不提供。

我们需要注意控制接口的粒度， 接口不能太小， 如果太小会导致系统中接口泛滥， 不利于维护； 接口也不能太大， 太大的接 口将违背接口隔离原则， 灵活性较 差， 使用起来很不方便。 一般而言， 接口中仅包含为某一类用户定制的方法即可， 不应该 强 迫客户依赖于那些它们不用的方法。

### 迪米特法则

迪米特原则 （ Law of Demeter LoD） 是指一个对象应该对其他对象保持最少的了解， 又叫最少知道原则 （Least Knowledge Principle,LKP） ， 尽量降低类与类之间的耦合。（一个软件实体应当尽可能少地与其他实体发生相互作用）

迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类， 而出现在方法体内部的类不属于朋友类。

如果一个系统符合迪米特法则， 那么当其中某一个模块发生修改时， 就会尽量少地影响其他模块， 扩展会相对容易， 这是对软件实体之间通信的限制， 迪米特法则要求限制软件实体之间通信的宽度和深度。

迪米特法则可降低系统的耦合度， 使类与类之间保持松散的耦合关系。 迪米特法则要求我们在设计系统时， 应该尽量减少对象之间的交互， 如果两个对象之间不必彼此直接通信， 那么这两个对象就不应当发生任何直接的相互作用， 如果其中的一个对象需要调用另一个对象的某一个方法的话， 可以通过第三者转发这个调用。 简言之， 就是通过引 入一个合理的第三者来降低现有对象之间的耦合度。



## 里氏替换原则

里氏替换原则 （ Liskov Substitution Principle,LSP）是所有引用基类（父类） 的地方必须能透明地使用其子类的对象。

里氏代换原则可以通俗表述为： 在软件中将一个基类对象替换成它的子类对象， 程序将不会产生任何错误和异常， 反过来则不成立， 如果一个软件实体使用的是一个子类对象的话， 那么它不一定能够使用基类对象。

里氏代换原则是实现开闭原则的重要方式之一， 由于使用基类对象的地方都可以使用子类对象， 因此在程序中尽量使用基类类型来对对象进行定义， 而在运行时再确定其子类类型， 用子类对象来替换父类对象。

里氏代换原则需要注意事项：

- 子类的所有方法必须在父类中声明， 或子类必须实现父类中声明的所有方法。 根据里氏替换原则， 为了保证系统的扩展性， 在程序中通常使用父类来进行定义， 如果一个方法只存在子类中， 在父类中不提供相应的声明， 则无法在以父类定义的对象中使用该方法。
- 运用里氏代换原则时， 尽量把父类设计为抽象类或者接口， 让子类继承父类或实现父接口， 并实现在父类中声明的方法， 运行时， 子类实例替换父类实例， 我们可以很方便地 扩展系统的功能， 同时无须修改原有子类的代 码， 增加新的功能可以通过增加一个新的子类来实现。 里氏代换原则是开闭原则的具体实现手段之一。
- Java 语言中， 在编译阶段， Java 编译器会检查一个程序是否符合里氏代换原则， 这是一个与实现无关的、 纯语法意义上的检查， 但 Java 编译器的检查是有局限的。

里氏替换的含义：

-  子类可以扩展父类的功能， 但不能改变父类原有的功能。
- 子类可以实现父类的抽象方法， 但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时， 方法的前置条件（即方法的输入/入参） 要比父类方法的输入 参数更宽松。
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法） ， 方法的后置条件（即方法的输 出/返回值） 要比父类更严格或相等。

里氏替换的优点：

- 约束继承泛滥， 开闭原则的一种体现。
-  加强程序的健壮性， 同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。

### 合成复用原则

合成复用原则 （Composite/Aggregate Reuse Principle,CARP） 是指尽量使用对象组合(has-a)/ 聚合(contains-a)， 而不是继承关系达到软件复用的目的。可以使系统更加灵活， 降低类与类之间的耦合度， 一个类的变化对其他类造成的影响相对较少。

继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。 要根据具体的业务场景来做代码设计， 其实也都需要遵循 OOP 模型。

合成复用原则就是在一个新的对象里通过关联关系 （包括组合关系和聚合关系） 来使用一些已有的对象， 使之成为新对象的一部分；

新对象通过委派调用已有对象的方法达到复用功能的目的。 简言之： 复用时要尽量使用组 合 / 聚合关系（关联关系） ， 少用继承。

在面向对象设计中， 可以通过两种方法在不同的环境中复用已有的设计和实现， 即通过组合 / 聚合关系或通过继承， 但首先应该考虑使用组合 / 聚合， 组合 / 聚合可以使系统更加灵活， 降低 类与类之间的耦合度， 一个类的变化对其 他类造成的影响相对较少； 其次才考虑继承， 在使 用继承时， 需要严格遵循里氏代换原则， 有效使用继承会有助于 对问题的理解， 降低复杂 度， 而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度， 因此需要慎重使用 继 承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性， 因为继承会将基类的实 现细节暴露给子 类， 由于基类的内部细节通常对子类来说是可见的， 所以这种复用又称 “ 白 箱 ” 复用， 如果基类发生改变， 那么子类的 实现也不得不发生改变； 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分， 因此 新对象可以调用已有对象的功能， 这样做可以使得成员对象的内部实现 细节对于新对象不可见。

总结：

复用的方式：

- ① 组合 / 聚合关系实现复用
- ② 继承实现复用

复用的问题

- 继承复用问题： 会破坏系统的封装性， 会把基类实现暴露给子类。
- 组合 / 聚合复用： 已有对象的功能细节， 对组合而成的新对象是不可见的， 封装性教好。

### 总结

在实际开发过程中， 并不是一定要求所有代码都遵循设计原则， 我们要考虑人力、 时间、 成本、 质量， 不是刻意追求完美， 要在适当的场景遵循设计原则， 体现的是一种平衡取舍， 帮助我们设计出更加优雅的代码结构。